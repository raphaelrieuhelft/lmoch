open Aez
open Smt

module BMC_solver = Smt.Make(struct end)
module Kind_solver = Smt.Make(struct end)

exception FalseProperty of int
exception TrueProperty of int

let declare_symbol name t_in t_out =
	let x = Hstring.make name in (* creation dâ€™un symbole *)
	Symbol.declare x t_in t_out; (* declaration de son type *)
	x

let kind delta_incr p_incr =
	let k = ref 0 in
	let n = Term.make_app (declare_symbol "n" [] Type.type_int) [] in
	let n_plus_k = ref n in
	let f_base = ref (p_incr (Term.make_int (Num.Int 0))) in
	BMC_solver.assume ~id:0 (delta_incr (Term.make_int (Num.Int 0)));
	BMC_solver.check();
	Kind_solver.assume ~id:0 (Formula.make_lit Formula.Lt [Term.make_int (Num.Int 0); n]);
	Kind_solver.assume ~id:0 (delta_incr !n_plus_k);
	Kind_solver.assume ~id:0 (p_incr !n_plus_k);
	Kind_solver.check();
	try (while true do
		incr k;
		n_plus_k := Term.make_arith Term.Plus !n_plus_k (Term.make_int (Num.Int 1));
		f_base := Formula.make Formula.And [!f_base; p_incr (Term.make_int (Num.Int !k))];
		BMC_solver.assume ~id:0 (delta_incr (Term.make_int (Num.Int !k)));
		if not (BMC_solver.entails ~id:0 !f_base;) then raise (FalseProperty !k)
		else begin
			(*Formula.print Format.std_formatter (Formula.make Formula.And [(delta_incr !n_plus_k); (Formula.make_lit Formula.Lt [Term.make_int (Num.Int 0); n])]);
			Format.printf "@.";*)
			Kind_solver.assume ~id:0 (delta_incr !n_plus_k);
			Kind_solver.check();
			let p_next = p_incr !n_plus_k in
			if Kind_solver.entails ~id:0 p_next then ((*Formula.print Format.std_formatter p_next;*) raise (TrueProperty !k))
			else Kind_solver.assume ~id:0 p_next
		end
		done
	)
	with 
	  | TrueProperty k -> 
	    Format.printf "TRUE PROPERTY@.";
		Format.printf "Proven with a %i-induction.@." k
	  | FalseProperty k -> 
	    Format.printf "FALSE PROPERTY@.";
		Format.printf "Base case failed for n = %i.@." k

(*Beginning autogenerated proof*) 

let b__15 = declare_symbol "b__15" [ Type.type_int ] Type.type_bool
let a__14 = declare_symbol "a__14" [ Type.type_int ] Type.type_bool
let out__16 = declare_symbol "out__16" [ Type.type_int ] Type.type_bool
let check__13 = declare_symbol "check__13" [ Type.type_int ] Type.type_bool
let aux__20 = declare_symbol "aux__20" [ Type.type_int ] Type.type_bool
let mux_a__26 = declare_symbol "mux_a__26" [ Type.type_int ] Type.type_bool
let mux_b__25 = declare_symbol "mux_b__25" [ Type.type_int ] Type.type_bool
let mux_sel__24 = declare_symbol "mux_sel__24" [ Type.type_int ] Type.type_bool
let mux_out__23 = declare_symbol "mux_out__23" [ Type.type_int ] Type.type_bool
let dmux_in__28 = declare_symbol "dmux_in__28" [ Type.type_int ] Type.type_bool
let dmux_sel__27 = declare_symbol "dmux_sel__27" [ Type.type_int ] Type.type_bool
let dmux_b__22 = declare_symbol "dmux_b__22" [ Type.type_int ] Type.type_bool
let dmux_a__21 = declare_symbol "dmux_a__21" [ Type.type_int ] Type.type_bool
let in__17 = declare_symbol "in__17" [ Type.type_int ] Type.type_bool
let sel__18 = declare_symbol "sel__18" [ Type.type_int ] Type.type_bool
let def_b__15 n =
  (*  b__15(n)  =  dmux_b__22(n)  *)
  let b__15_term = Term.make_app dmux_b__22
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app b__15
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; b__15_term ]
let def_a__14 n =
  (*  a__14(n)  =  dmux_a__21(n)  *)
  let a__14_term = Term.make_app dmux_a__21
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app a__14
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; a__14_term ]
let def_out__16 n =
  (*  out__16(n)  =  mux_out__23(n)  *)
  let out__16_term = Term.make_app mux_out__23
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app out__16
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; out__16_term ]
let def_check__13 n =
  (*  check__13(n)  =  aux__20(n)  *)
  let check__13_term = Term.make_app aux__20
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app check__13
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; check__13_term ]
let def_aux__20 n =
  (*  (aux__20(n)  ==>  (out__16(n) = in__17(n)))  &&  ((out__16(n) = in__17(n))  ==>  aux__20(n))  *)
  let aux__20_n = Formula.make_lit Formula.Eq [ Term.make_app aux__20
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; Term.t_true ]
  in
  let aux__20_formula = Formula.make_lit Formula.Eq [ Term.make_app out__16
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; Term.make_app in__17
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
     ]
  in
  Formula.make Formula.And [
    Formula.make Formula.Imp [ aux__20_n; aux__20_formula ];
    Formula.make Formula.Imp [ aux__20_formula; aux__20_n ]
   ]


let def_mux_a__26 n =
  (*  mux_a__26(n)  =  a__14(n)  *)
  let mux_a__26_term = Term.make_app a__14
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app mux_a__26
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; mux_a__26_term ]
let def_mux_b__25 n =
  (*  mux_b__25(n)  =  b__15(n)  *)
  let mux_b__25_term = Term.make_app b__15
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app mux_b__25
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; mux_b__25_term ]
let def_mux_sel__24 n =
  (*  mux_sel__24(n)  =  sel__18(n)  *)
  let mux_sel__24_term = Term.make_app sel__18
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app mux_sel__24
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; mux_sel__24_term ]
let def_mux_out__23 n =
  (*  mux_out__23(n)  =  (if mux_sel__24(n) then mux_b__25(n) else mux_a__26(n))  *)
  let mux_out__23_term = Term.make_ite
    (Formula.make_lit Formula.Eq [ Term.make_app mux_sel__24
      [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
      ; Term.t_true ])
    (Term.make_app mux_b__25
      [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
      )
    (Term.make_app mux_a__26
      [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
      )
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app mux_out__23
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; mux_out__23_term ]
let def_dmux_in__28 n =
  (*  dmux_in__28(n)  =  in__17(n)  *)
  let dmux_in__28_term = Term.make_app in__17
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app dmux_in__28
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; dmux_in__28_term ]
let def_dmux_sel__27 n =
  (*  dmux_sel__27(n)  =  sel__18(n)  *)
  let dmux_sel__27_term = Term.make_app sel__18
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app dmux_sel__27
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; dmux_sel__27_term ]
let def_dmux_b__22 n =
  (*  dmux_b__22(n)  =  (if dmux_sel__27(n) then dmux_in__28(n) else false)  *)
  let dmux_b__22_term = Term.make_ite
    (Formula.make_lit Formula.Eq [ Term.make_app dmux_sel__27
      [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
      ; Term.t_true ])
    (Term.make_app dmux_in__28
      [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
      )
    (Term.t_false)
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app dmux_b__22
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; dmux_b__22_term ]
let def_dmux_a__21 n =
  (*  dmux_a__21(n)  =  (if dmux_sel__27(n) then false else dmux_in__28(n))  *)
  let dmux_a__21_term = Term.make_ite
    (Formula.make_lit Formula.Eq [ Term.make_app dmux_sel__27
      [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
      ; Term.t_true ])
    (Term.t_false)
    (Term.make_app dmux_in__28
      [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
      )
    
  in
  Formula.make_lit Formula.Eq [ Term.make_app dmux_a__21
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; dmux_a__21_term ]
let delta_incr n = Formula.make Formula.And [ def_b__15 n; def_a__14 n; def_out__16 n; def_check__13 n; def_aux__20 n; def_mux_a__26 n; def_mux_b__25 n; def_mux_sel__24 n; def_mux_out__23 n; def_dmux_in__28 n; def_dmux_sel__27 n; def_dmux_b__22 n; def_dmux_a__21 n ]
let p_incr n = Formula.make_lit Formula.Eq [ Term.make_app check__13
    [ Term.make_arith Term.Minus n (Term.make_int (Num.Int 0)) ]
    ; Term.t_true ]
let () = kind delta_incr p_incr

